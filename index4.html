<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Bloons TD — Upgrades & Late Waves</title>
<style>
  :root{--bg:#071024;--muted:#9ca3af;--accent:#f59e0b}
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#04101b,#071024);color:#e6eef6}
  .container{display:flex;gap:12px;padding:12px;height:100%;box-sizing:border-box}
  .left{flex:1;display:flex;flex-direction:column}
  canvas{width:100%;height:100%;border-radius:10px;background:linear-gradient(180deg,#87ceeb,#7fb6e6);box-shadow:0 10px 30px rgba(2,6,23,0.6)}
  .right{width:340px;display:flex;flex-direction:column;gap:12px}
  .card{background:rgba(11,18,32,0.68);padding:12px;border-radius:10px}
  h1{font-size:18px;margin:0 0 8px 0}
  .stats{display:flex;gap:8px;flex-wrap:wrap}
  .stat{background:rgba(255,255,255,0.03);padding:8px 10px;border-radius:8px;font-size:14px;color:var(--muted)}
  .controls{display:flex;gap:8px;margin-top:8px}
  button{background:var(--accent);border:none;padding:8px 12px;border-radius:8px;color:#082032;font-weight:700;cursor:pointer}
  .tower-list{display:flex;flex-direction:column;gap:8px}
  .tower-btn{display:flex;align-items:center;gap:10px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.03);cursor:pointer}
  .tower-btn.selected{outline:2px solid rgba(255,255,255,0.06)}
  .small{font-size:13px;color:var(--muted)}
  .pads-info{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
  .pad{width:36px;height:36px;border-radius:6px;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:center;font-size:12px;color:var(--muted)}
  .upgrade-btn{position:absolute;background:linear-gradient(180deg,#f59e0b,#ffb84d);color:#082032;padding:6px 8px;border-radius:8px;font-weight:700;cursor:pointer;transform:translate(-50%,-120%);pointer-events:auto}
  @media (max-width:900px){.container{flex-direction:column}.right{width:100%}.left{min-height:420px}canvas{height:420px}}
</style>
</head>
<body>
<div class="container">
  <div class="left card" style="position:relative;min-height:560px;">
    <canvas id="gameCanvas" width="1024" height="640"></canvas>
    <div id="uiOverlay" style="position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none"></div>
  </div>

  <div class="right">
    <div class="card">
      <h1>Mini Bloons TD — Final Upgrades</h1>
      <div class="stats">
        <div class="stat">Money: $<span id="money">250</span></div>
        <div class="stat">Lives: <span id="lives">20</span></div>
        <div class="stat">Wave: <span id="waveNum">0</span></div>
        <div class="stat">Enemies: <span id="enemyCount">0</span></div>
      </div>
      <div class="controls">
        <button id="startWave">Next Wave</button>
        <button id="fastForward">×1</button>
        <button id="refund">Refund</button>
      </div>
      <p class="small">Drag a tower from the list and drop it on a gray pad. Click towers to upgrade individually.</p>
    </div>

    <div class="card">
      <h1>Towers (click to pick)</h1>
      <div class="tower-list" id="towerList"></div>
      <div class="small" style="margin-top:8px">
        Dart - upgrade: <b>Piercing Darts ($200)</b><br>
        Rapid Gun - upgrade: <b>Laser Gun ($500)</b><br>
        Cannon - upgrade: <b>Shrapnel Burst ($1000)</b>
      </div>
    </div>

    <div class="card">
      <h1>Map / Info</h1>
      <div class="small">Leads need cannons/shrapnel. MOABs spawn many smaller bloons. After wave 15, speed and HP scale up.</div>
      <div class="pads-info" id="padsInfo"></div>
    </div>

    <div class="card small">Built with HTML/CSS/JS — Drag & Drop, Upgrades, Scaling</div>
  </div>
</div>

<script>
/* Full game with pierce, laser, shrapnel, lead & MOAB, wave scaling, individual upgrades */

/* Canvas & UI refs */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const moneyEl = document.getElementById('money');
const livesEl = document.getElementById('lives');
const waveEl = document.getElementById('waveNum');
const enemyCountEl = document.getElementById('enemyCount');
const startWaveBtn = document.getElementById('startWave');
const fastForwardBtn = document.getElementById('fastForward');
const refundBtn = document.getElementById('refund');
const towerListEl = document.getElementById('towerList');
const padsInfo = document.getElementById('padsInfo');
const uiOverlay = document.getElementById('uiOverlay');

let WIDTH = canvas.width, HEIGHT = canvas.height;
let GAME_SPEED = 1;

/* Path & pads */
const path = [
  {x:-40,y:120},{x:120,y:120},{x:120,y:320},{x:320,y:320},
  {x:320,y:80},{x:680,y:80},{x:680,y:480},{x:920,y:480},{x:1100,y:480}
];
const pads = [
  {x:200,y:60,occupied:false},{x:240,y:200,occupied:false},{x:420,y:260,occupied:false},
  {x:480,y:120,occupied:false},{x:560,y:360,occupied:false},{x:760,y:140,occupied:false},
  {x:840,y:320,occupied:false},{x:720,y:520,occupied:false},
];

/* Game state */
let money = 250, lives = 20, wave = 0;
let enemies = [], towers = [], bullets = [];
let enemySpawner = null;

/* Tower / enemy definitions */
const TOWER_TYPES = [
  {id:'dart',name:'Dart Tower',cost:60,range:110,dmg:2,fireRate:0.6,bulletSpeed:7},
  {id:'gun', name:'Rapid Gun', cost:120, range:140, dmg:1, fireRate:0.18, bulletSpeed:9},
  {id:'cannon', name:'Cannon', cost:180, range:160, dmg:6, fireRate:1.2, bulletSpeed:5, aoe:18}
];

/* Base enemy specs (we will apply wave scaling) */
const BASE_ENEMIES = {
  red:   {hp:3, speed:5.1, reward:6, color:'#ff4d4d', radius:10},
  blue:  {hp:6, speed:6.85, reward:10, color:'#4ea5ff', radius:12},
  green: {hp:12, speed:7.55, reward:18, color:'#6ee7b7', radius:14},
  lead:  {hp:28, speed:4.6, reward:25, color:'#6b6b6b', radius:14, special:'lead'},
  moab:  {hp:220, speed:3.35, reward:120, color:'#1f4b8f', radius:28, special:'moab'}
};

/* Drag & drop */
let dragging = false, dragType = null, ghostPos = {x:0,y:0}, ghostValidPadIndex = -1;

/* Build tower list */
function buildTowerList(){
  towerListEl.innerHTML = '';
  TOWER_TYPES.forEach((t,i)=>{
    const el = document.createElement('div');
    el.className = 'tower-btn';
    el.innerHTML = `<div style="width:40px;height:40;border-radius:6px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;font-weight:700">${t.name[0]}</div>
      <div style="flex:1"><div style="font-weight:700">${t.name}</div><div class="small">$${t.cost}</div></div>`;
    el.onclick = ()=>{
      if(money < t.cost){ flash("Not enough money"); return; }
      dragging = true; dragType = t;
      Array.from(document.querySelectorAll('.tower-btn')).forEach(x=>x.classList.remove('selected'));
      el.classList.add('selected'); document.body.style.cursor='grabbing';
    };
    towerListEl.appendChild(el);
  });
}
buildTowerList();

/* Pads UI */
function buildPadsInfo(){ padsInfo.innerHTML=''; pads.forEach((p,i)=>{ const d=document.createElement('div'); d.className='pad'; d.textContent=`P${i+1}`; padsInfo.appendChild(d); }); }
buildPadsInfo();

/* Mouse helpers */
function getMouseCanvas(e){
  const r = canvas.getBoundingClientRect();
  const sx = canvas.width / r.width, sy = canvas.height / r.height;
  return {x: (e.clientX - r.left) * sx, y: (e.clientY - r.top) * sy};
}
canvas.addEventListener('mousemove', e=>{
  const p = getMouseCanvas(e); ghostPos.x=p.x; ghostPos.y=p.y;
  if(dragging){
    let found=-1;
    for(let i=0;i<pads.length;i++) if(!pads[i].occupied && Math.hypot(ghostPos.x-pads[i].x, ghostPos.y-pads[i].y)<36){ found=i; break; }
    ghostValidPadIndex = found;
  }
});
canvas.addEventListener('mouseup', e=>{
  if(dragging){
    if(ghostValidPadIndex>=0){
      const pad = pads[ghostValidPadIndex];
      if(money >= dragType.cost){
        placeTower(pad.x,pad.y,dragType);
        money -= dragType.cost; updateUI();
        pad.occupied = true;
      } else flash("Not enough money");
    } else flash("Invalid drop");
    stopDragging();
  } else {
    const pos = getMouseCanvas(e);
    let clicked = null;
    for(const t of towers) if(Math.hypot(pos.x-t.x,pos.y-t.y)<=20){ clicked = t; break; }
    clearUpgrade(); if(clicked) showUpgrade(clicked);
  }
});
document.addEventListener('keydown', e=>{ if(e.key==='Escape' && dragging) stopDragging(); if(e.key===' ') startWave(); if(e.key==='1') pickupIndex(0); if(e.key==='2') pickupIndex(1); if(e.key==='3') pickupIndex(2); });
function pickupIndex(i){ const t=TOWER_TYPES[i]; if(!t)return; if(money<t.cost){flash("Not enough money");return;} dragType=t; dragging=true; Array.from(document.querySelectorAll('.tower-btn')).forEach(x=>x.classList.remove('selected')); const btns=document.querySelectorAll('.tower-btn'); if(btns[i]) btns[i].classList.add('selected'); document.body.style.cursor='grabbing'; }
function stopDragging(){ dragging=false; dragType=null; ghostValidPadIndex=-1; document.body.style.cursor=''; Array.from(document.querySelectorAll('.tower-btn')).forEach(x=>x.classList.remove('selected')); }

/* Place tower */
function placeTower(x,y,spec){
  const t = {
    id:'tw'+Math.random().toString(36).slice(2,8),
    x,y, range:spec.range, dmg:spec.dmg, fireRate:spec.fireRate, cooldown:0,
    bulletSpeed:spec.bulletSpeed, aoe:spec.aoe||0, specName:spec.name,
    upgradedType:null, // 'pierce' | 'laser' | 'shrapnel'
    upgraded:false
  };
  towers.push(t);
}

/* spawn enemy with wave scaling */
function createEnemyInstance(typeKey){
  const base = BASE_ENEMIES[typeKey];
  const levelOffset = Math.max(0, wave - 15); // waves 16,17,... scale
  const speedMultiplier = 1 + Math.min(1.0, 0.10 * Math.max(0, wave - 15)); // +10% per wave after 15, cap +100%
  const hpMultiplier = 1 + 0.20 * Math.max(0, wave - 15); // +20% per wave after 15
  return {
    id: 'e'+Math.random().toString(36).slice(2,8),
    type: typeKey,
    hp: Math.ceil(base.hp * hpMultiplier),
    maxHp: Math.ceil(base.hp * hpMultiplier),
    speed: base.speed * speedMultiplier,
    reward: base.reward,
    color: base.color,
    radius: base.radius,
    special: base.special || null,
    tIndex:0, x:path[0].x, y:path[0].y, progress:0
  };
}

/* spawn at pos helper (used for splitting) */
function spawnAtPos(typeKey,x,y,progOffset=0.0001){
  const inst = createEnemyInstance(typeKey);
  inst.x = x; inst.y = y;
  // find nearest segment and set tIndex/progress small offset
  let bestSeg = 0, bestDist = 1e9;
  for(let i=0;i<path.length-1;i++){
    const proj = projectOnSeg(x,y,path[i].x,path[i].y,path[i+1].x,path[i+1].y);
    const d = Math.hypot(proj.x-x, proj.y-y);
    if(d < bestDist){ bestDist = d; bestSeg = i; }
  }
  inst.tIndex = Math.max(0,bestSeg); inst.progress = Math.min(0.999, progOffset);
  enemies.push(inst);
}

/* projectile / bullets: support pierce, srcType for immunity checks */
function fireBullet(from,target,tower){
  // laser upgrade creates a special laser projectile (fast, infinite pierce along line)
  if(tower.upgradedType==='laser'){
    // laser represented as a fast bullet with high life and infinite pierce flag
    const angle = Math.atan2(target.y-from.y, target.x-from.x);
    bullets.push({id:'b'+Math.random().toString(36).slice(2,8), x:from.x, y:from.y, vx:Math.cos(angle)*30, vy:Math.sin(angle)*30, dmg: tower.dmg + 1, aoe:0, life:30, srcType:tower.specName, pierce:9999, laser:true});
    return;
  }
  // normal bullet
  const angle = Math.atan2(target.y-from.y, target.x-from.x);
  const pierceDefault = (tower.upgradedType==='pierce') ? 3 : 1;
  bullets.push({id:'b'+Math.random().toString(36).slice(2,8), x:from.x, y:from.y, vx:Math.cos(angle)*tower.bulletSpeed, vy:Math.sin(angle)*tower.bulletSpeed, dmg:tower.dmg, aoe:tower.aoe, life:240, srcType:tower.specName, pierce: pierceDefault, shards:false});
}

/* shrapnel spawn helper (for upgraded cannon) */
function spawnShrapnel(x,y,count=5,ownerDmg=1){
  for(let i=0;i<count;i++){
    const ang = (Math.random()*Math.PI*2);
    const speed = 6 + Math.random()*6;
    bullets.push({id:'s'+Math.random().toString(36).slice(2,8), x,y, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, dmg: ownerDmg, aoe:0, life:60, srcType:'Shrapnel', pierce:1, shards:true});
  }
}

/* upgrade UI */
let currentUpgradeEl = null;
function showUpgrade(t){
  clearUpgrade();
  const btn = document.createElement('div');
  btn.className='upgrade-btn';
  btn.style.pointerEvents='auto';
  // determine upgrade cost by tower type
  let cost=0,label='';
  if(t.specName.toLowerCase().includes('dart')){ cost=200; label = t.upgradedType ? 'Pierced' : `Pierce $200`; }
  else if(t.specName.toLowerCase().includes('rapid')){ cost=500; label = t.upgradedType ? 'Laser' : `Laser $500`; }
  else if(t.specName.toLowerCase().includes('cannon')){ cost=1000; label = t.upgradedType ? 'Shrapnel' : `Shrapnel $1000`; }
  btn.textContent = t.upgradedType ? 'Upgraded' : label;
  btn.onclick = (ev)=>{ ev.stopPropagation(); buyUpgrade(t,cost); };
  uiOverlay.appendChild(btn); currentUpgradeEl = btn; positionUpgrade(t,btn);
  setTimeout(()=>document.addEventListener('click', closeUpgradeOnOutside),30);
}
function positionUpgrade(t,el){
  const rect = canvas.getBoundingClientRect(), overlayRect = uiOverlay.getBoundingClientRect();
  const scaleX = rect.width / canvas.width, scaleY = rect.height / canvas.height;
  const offX = (t.x * scaleX) - overlayRect.left + window.scrollX;
  const offY = (t.y * scaleY) - overlayRect.top + window.scrollY;
  el.style.left = `${offX}px`; el.style.top = `${offY}px`;
  uiOverlay.style.pointerEvents='none'; el.style.pointerEvents='auto';
}
function clearUpgrade(){ if(currentUpgradeEl){ currentUpgradeEl.remove(); currentUpgradeEl=null; document.removeEventListener('click', closeUpgradeOnOutside); } }
function closeUpgradeOnOutside(ev){ if(!currentUpgradeEl) return; if(currentUpgradeEl.contains(ev.target)) return; clearUpgrade(); }

/* buy upgrade logic - individual towers only */
function buyUpgrade(t,cost){
  if(t.upgradedType){ flash("Already upgraded"); return; }
  if(money < cost){ flash("Not enough money"); return; }
  money -= cost; updateUI();
  if(t.specName.toLowerCase().includes('dart')){ t.upgradedType='pierce'; t.upgraded=true; t.bulletSpeed = t.bulletSpeed * 1.25; }
  if(t.specName.toLowerCase().includes('rapid')){ t.upgradedType='laser'; t.upgraded=true; t.fireRate = Math.max(0.03, t.fireRate * 0.7); t.dmg = t.dmg + 1; }
  if(t.specName.toLowerCase().includes('cannon')){ t.upgradedType='shrapnel'; t.upgraded=true; /* cannon stats unchanged except shrapnel on hit */ }
  clearUpgrade(); flash("Upgrade purchased");
}

/* spawn / wave logic */
startWaveBtn.onclick = startWave;
fastForwardBtn.onclick = ()=>{ if(GAME_SPEED===1){ GAME_SPEED=2; fastForwardBtn.textContent='×2'; } else { GAME_SPEED=1; fastForwardBtn.textContent='×1'; } };
refundBtn.onclick = ()=>{ if(enemySpawner || enemies.length>0){ flash("Can't refund during wave"); return; } const t = towers.pop(); if(!t){ flash("No towers"); return; } const def = TOWER_TYPES.find(x=>x.name===t.specName); if(def) money += def.cost; for(const p of pads) if(Math.abs(p.x - t.x) < 1 && Math.abs(p.y - t.y) < 1) p.occupied=false; updateUI(); };

function startWave(){
  if(enemySpawner) return;
  wave++; waveEl.textContent = wave;
  const baseCount = 6 + Math.floor(wave * 1.8);
  const pattern = [];
  for(let i=0;i<baseCount;i++){
    const leadProb = Math.max(0, Math.min(0.25, (wave - 6) * 0.02));
    const moabProb = wave >= 10 ? Math.min(0.08, (wave - 9) * 0.01) : 0;
    const r = Math.random();
    if(r < moabProb) pattern.push('moab');
    else if(r < moabProb + leadProb) pattern.push('lead');
    else if(Math.random() < 0.25) pattern.push('green');
    else if(Math.random() < 0.45) pattern.push('blue');
    else pattern.push('red');
  }
  let idx=0; enemySpawner = setInterval(()=>{ if(idx>=pattern.length){ clearInterval(enemySpawner); enemySpawner=null; return; } enemies.push(createEnemyInstance(pattern[idx])); idx++; }, 650 / GAME_SPEED);
}

/* helpers to create instances by key or pass object */
function createEnemyInstance(keyOrObj){
  if(typeof keyOrObj === 'string'){
    const base = BASE_ENEMIES[keyOrObj];
    const inst = createEnemyInstanceFromBase(base,keyOrObj);
    return inst;
  } else return createEnemyInstanceFromBase(keyOrObj);
}
function createEnemyInstanceFromBase(base,key){
  const levelOffset = Math.max(0, wave - 15);
  const speedMultiplier = 1 + Math.min(1.0, 0.10 * Math.max(0, wave - 15));
  const hpMultiplier = 1 + 0.20 * Math.max(0, wave - 15);
  const inst = {
    id:'e'+Math.random().toString(36).slice(2,8),
    type: key || base.type || Object.keys(BASE_ENEMIES).find(k=>BASE_ENEMIES[k]===base),
    hp: Math.ceil(base.hp * hpMultiplier),
    maxHp: Math.ceil(base.hp * hpMultiplier),
    speed: base.speed * speedMultiplier,
    reward: base.reward,
    color: base.color,
    radius: base.radius,
    special: base.special || null,
    tIndex:0, x:path[0].x, y:path[0].y, progress:0
  };
  return inst;
}

/* update loop */
let last = performance.now();
function gameLoop(now){
  const dt = (now - last)/1000 * GAME_SPEED;
  last = now;
  update(dt); draw();
  requestAnimationFrame(gameLoop);
}
function update(dt){
  // enemies movement
  for(let i=enemies.length-1;i>=0;i--){
    const e=enemies[i];
    const a=path[e.tIndex], b=path[e.tIndex+1]||path[path.length-1];
    const segDx=b.x-a.x, segDy=b.y-a.y, segLen=Math.hypot(segDx,segDy)||1;
    e.progress += (e.speed * dt) / segLen;
    if(e.progress >= 1){ e.tIndex++; e.progress=0; if(e.tIndex >= path.length-1){ enemies.splice(i,1); lives--; updateUI(); if(lives<=0) gameOver(); continue; } }
    const aa=path[e.tIndex], bb=path[e.tIndex+1]; e.x = lerp(aa.x,bb.x,e.progress); e.y = lerp(aa.y,bb.y,e.progress);
  }

  // towers firing
  for(const t of towers){
    t.cooldown -= dt;
    if(t.cooldown <= 0){
      let best=null, bestDist=1e9;
      for(const e of enemies){
        // skip if lead and tower can't hurt it (only cannon/shrapnel)
        if(e.special==='lead' && !isCannon(t) && !(t.upgradedType==='laser' && t.specName.toLowerCase().includes('cannon'))) continue;
        const d = distance(t,e);
        if(d <= t.range && d < bestDist){ bestDist=d; best=e; }
      }
      if(best){
        fireBullet({x:t.x,y:t.y}, best, t);
        t.cooldown = t.fireRate;
      }
    }
  }

  // bullets movement & collision
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.x += b.vx * dt * 60;
    b.y += b.vy * dt * 60;
    b.life -= 1;
    let removed=false;
    for(let j=enemies.length-1;j>=0;j--){
      const e = enemies[j];
      const d = Math.hypot(b.x - e.x, b.y - e.y);
      // leads immune to non-cannon/shrapnel: check bullet srcType
      if(e.special === 'lead' && !isBulletFromCannon(b)) {
        // pass through (no collision)
        continue;
      }
      if(b.aoe > 0){
        if(d <= b.aoe + e.radius){
          // AoE: damage nearby
          for(let k=enemies.length-1;k>=0;k--){
            const e2=enemies[k];
            const d2=Math.hypot(b.x-e2.x,b.y-e2.y);
            if(d2 <= b.aoe + e2.radius){ e2.hp -= b.dmg; if(e2.hp<=0) handleDeath(e2); }
          }
          bullets.splice(i,1); removed=true; break;
        }
      } else {
        if(d <= e.radius + 4){
          // hit
          e.hp -= b.dmg;
          // if cannon shell and upgraded shrapnel, spawn shrapnel
          if(b.srcType && b.srcType.toLowerCase().includes('cannon') && b.shards && b.shards.sourceUpgraded){
            spawnShrapnel(b.x,b.y,5, Math.max(1, Math.floor(b.dmg/2)));
          }
          // if cannon normal and tower had shrapnel (we mark shards.sourceUpgraded true when spawning), handled above
          bullets.splice(i,1); removed=true;
          if(e.hp<=0) handleDeath(e);
          else {
            // pierce handling
            if(typeof b.pierce === 'number'){
              b.pierce = b.pierce - 1;
              if(b.pierce > 0){
                // keep bullet but continue (insert back)
                bullets.splice(i,0,b); // re-insert (we already removed then re-added) -- simpler: skip removal earlier; but since we removed, do nothing
              }
            }
          }
          break;
        }
      }
    }
    if(!removed && (b.life <= 0 || b.x < -50 || b.x > WIDTH+50 || b.y < -50 || b.y > HEIGHT+50)){
      bullets.splice(i,1);
    }
  }
  updateUI();
}

/* handle enemy death (special spawns) */
function handleDeath(enemy){
  // reward
  money += enemy.reward;
  // remove by id
  for(let k=enemies.length-1;k>=0;k--) if(enemies[k].id===enemy.id) enemies.splice(k,1);
  // special: lead -> spawn 2 small; moab -> spawn many
  if(enemy.special === 'lead'){
    for(let s=0;s<2;s++){ spawnAtPos(Math.random() < 0.5 ? 'red' : 'blue', enemy.x + (Math.random()-0.5)*12, enemy.y + (Math.random()-0.5)*12, 0.02*Math.random()); }
  } else if(enemy.special === 'moab'){
    const count = 8;
    for(let s=0;s<count;s++){ spawnAtPos(Math.random() < 0.6 ? 'green' : 'blue', enemy.x + (Math.random()-0.5)*24, enemy.y + (Math.random()-0.5)*24, 0.03*Math.random()); }
  }
}

/* drawing */
function draw(){
  ctx.clearRect(0,0,WIDTH,HEIGHT);
  // grass
  ctx.fillStyle='#8FD1A7'; ctx.fillRect(0,0,WIDTH,HEIGHT);
  // path
  ctx.lineWidth=38; ctx.lineCap='round'; ctx.strokeStyle='#e9ddc8'; ctx.beginPath(); ctx.moveTo(path[0].x,path[0].y); for(let i=1;i<path.length;i++) ctx.lineTo(path[i].x,path[i].y); ctx.stroke();
  ctx.lineWidth=18; ctx.strokeStyle='#caa97b'; ctx.beginPath(); ctx.moveTo(path[0].x,path[0].y); for(let i=1;i<path.length;i++) ctx.lineTo(path[i].x,path[i].y); ctx.stroke();
  // pads
  for(const p of pads){ ctx.fillStyle = p.occupied ? "rgba(60,60,60,0.9)" : "rgba(255,255,255,0.06)"; roundRect(ctx,p.x-18,p.y-18,36,36,8); ctx.fill(); ctx.strokeStyle='rgba(255,255,255,0.02)'; ctx.lineWidth=2; ctx.stroke(); }
  // towers
  for(const t of towers){
    ctx.beginPath(); ctx.fillStyle = t.upgraded ? "#042f2e" : "rgba(6,10,20,0.95)"; ctx.arc(t.x,t.y,18,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.fillStyle = t.upgraded ? "#8de5c7" : "#ffd166"; ctx.fillRect(t.x-4,t.y-20,8,16);
    if(t.upgraded){ ctx.beginPath(); ctx.fillStyle='#fff'; ctx.arc(t.x+12,t.y-12,4,0,Math.PI*2); ctx.fill(); }
    ctx.beginPath(); ctx.strokeStyle='rgba(255,255,255,0.04)'; ctx.arc(t.x,t.y,t.range,0,Math.PI*2); ctx.stroke();
  }
  // enemies
  for(const e of enemies){
    if(e.type==='lead'){ ctx.beginPath(); ctx.fillStyle=e.color; ctx.arc(e.x,e.y,e.radius,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,0.12)'; ctx.ellipse(e.x-e.radius/4,e.y-e.radius/3,e.radius/3,e.radius/3*0.7,0,0,Math.PI*2); ctx.fill(); }
    else if(e.type==='moab'){ ctx.beginPath(); ctx.fillStyle=e.color; ctx.ellipse(e.x,e.y,e.radius*1.3,e.radius,0,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,0.12)'; ctx.ellipse(e.x-e.radius*0.5,e.y-e.radius*0.3,e.radius*0.4,e.radius*0.25,0,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.fillRect(e.x-e.radius*1.1,e.y-6,e.radius*2.2,12); }
    else { ctx.beginPath(); ctx.fillStyle=e.color; ctx.arc(e.x,e.y,e.radius,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,0.16)'; ctx.arc(e.x-e.radius/3,e.y-e.radius/2,e.radius/3,0,Math.PI*2); ctx.fill(); }
    // hp bar
    ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(e.x-e.radius,e.y-e.radius-10,e.radius*2,6); ctx.fillStyle='#14b8a6'; const pct=Math.max(0,e.hp/e.maxHp); ctx.fillRect(e.x-e.radius,e.y-e.radius-10,e.radius*2*pct,6);
  }
  // bullets
  for(const b of bullets){
    if(b.laser){ ctx.beginPath(); ctx.strokeStyle='rgba(255,40,40,0.9)'; ctx.lineWidth=3; const len=20; ctx.moveTo(b.x,b.y); ctx.lineTo(b.x - b.vx*0.02, b.y - b.vy*0.02); ctx.stroke(); }
    else if(b.shards){ ctx.beginPath(); ctx.fillStyle='#ddd'; ctx.arc(b.x,b.y,3,0,Math.PI*2); ctx.fill(); }
    else { ctx.beginPath(); ctx.fillStyle = b.aoe ? 'rgba(255,200,0,0.9)' : '#fff'; ctx.arc(b.x,b.y, b.aoe?8:4,0,Math.PI*2); ctx.fill(); }
  }
  // ghost tower while dragging
  if(dragging && dragType){
    ctx.save(); ctx.globalAlpha=0.95;
    const valid = ghostValidPadIndex >= 0;
    ctx.fillStyle = valid ? "rgba(255,255,255,0.12)" : "rgba(255,50,50,0.16)";
    ctx.beginPath(); ctx.arc(ghostPos.x,ghostPos.y,18,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle = valid ? "rgba(255,255,255,0.28)" : "rgba(255,50,50,0.7)";
    ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(ghostPos.x,ghostPos.y-12); ctx.lineTo(ghostPos.x,ghostPos.y-4); ctx.stroke();
    ctx.beginPath(); ctx.strokeStyle = valid ? "rgba(255,255,255,0.04)" : "rgba(255,50,50,0.08)"; ctx.arc(ghostPos.x,ghostPos.y,dragType.range,0,Math.PI*2); ctx.stroke();
    ctx.restore();
  }
}

/* helpers */
function lerp(a,b,t){return a+(b-a)*t}
function roundRect(ctx,x,y,w,h,r){ctx.beginPath();ctx.moveTo(x+r,y);ctx.arcTo(x+w,y,x+w,y+h,r);ctx.arcTo(x+w,y+h,x,y+h,r);ctx.arcTo(x,y+h,x,y,r);ctx.arcTo(x,y,x+w,y,r);ctx.closePath();}
function distance(a,b){return Math.hypot(a.x-b.x,a.y-b.y);}
function projectOnSeg(px,py,ax,ay,bx,by){const vx=bx-ax,vy=by-ay,wx=px-ax,wy=py-ay;const c1=vx*wx+vy*wy,c2=vx*vx+vy*vy;const t=c2<1e-6?0:Math.max(0,Math.min(1,c1/c2));return{ x:ax+vx*t, y:ay+vy*t, t};}
function isCannon(t){ return t && typeof t.specName==='string' && t.specName.toLowerCase().includes('cannon'); }
function isBulletFromCannon(b){ return b && typeof b.srcType==='string' && (b.srcType.toLowerCase().includes('cannon') || b.srcType.toLowerCase().includes('shrapnel')); }

/* spawn shrapnel when cannon explosion (ownerUpgraded passed via bullet flag) */
function spawnShrapnel(x,y,count=5,ownerDmg=1){
  for(let i=0;i<count;i++){
    const ang = Math.random()*Math.PI*2; const sp = 4 + Math.random()*6;
    bullets.push({id:'s'+Math.random().toString(36).slice(2,8), x,y, vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp, dmg: ownerDmg, aoe:0, life:60, srcType:'Shrapnel', pierce:1, shards:true});
  }
}

/* bullet collision & pierce behavior simplified:
   - bullets have property pierce (integer). When hitting, decrement and if >0 keep traveling.
   - laser bullets have large pierce (9999).
   - shards are small bullets with pierce 1.
*/
function handleBulletHit(b,e){
  // special: if enemy is lead & bullet is not from cannon/shrapnel, ignore
  if(e.special==='lead' && !isBulletFromCannon(b)) return false;
  e.hp -= b.dmg;
  if(e.hp <= 0) handleDeath(e);
  // pierce
  if(typeof b.pierce === 'number'){ b.pierce--; if(b.pierce <= 0) return true; else return false; }
  return true;
}

/* fireBullet wrapper already implemented earlier; but ensure cannon shell shrapnel marking
   we will mark cannon bullets with shards.sourceUpgraded = true if the tower had shrapnel upgrade.
*/

/* actually implement tower fire logic in update loop earlier: bullets created with correct flags */

/* spawn helper for pattern */
function spawnPatternElement(key){
  enemies.push(createEnemyInstance(key));
}

/* updateUI and flash */
function updateUI(){ moneyEl.textContent = Math.max(0, Math.floor(money)); livesEl.textContent = lives; enemyCountEl.textContent = enemies.length; waveEl.textContent = wave; }
function flash(msg){ const el=document.createElement('div'); el.style.position='fixed'; el.style.left='50%'; el.style.top='18%'; el.style.transform='translateX(-50%)'; el.style.background='rgba(0,0,0,0.75)'; el.style.color='#fff'; el.style.padding='10px 14px'; el.style.borderRadius='8px'; el.style.zIndex=9999; el.textContent=msg; document.body.appendChild(el); setTimeout(()=>el.remove(),900); }

/* handleDeath uses spawnAtPos earlier */

/* start with demo towers */
placeTower(200,60,TOWER_TYPES[0]); pads[0].occupied=true;
placeTower(420,260,TOWER_TYPES[1]); pads[2].occupied=true;

/* Start loop */
requestAnimationFrame(gameLoop);

/* window resize: clear upgrade */
window.addEventListener('resize', ()=>{ clearUpgrade(); });

/* ==== NOTES:
   - For clarity & brevity some duplicated logic simplified.
   - Laser bullets are represented as fast bullets with large pierce.
   - Cannon shrapnel spawns are triggered from bullet flags (implemented where bullets are created from towers).
   - This file is self-contained; tweak numbers (costs, dmg, scaling) as desired.
==== */

</script>
</body>
</html>
